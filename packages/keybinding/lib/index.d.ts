// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@fin/contextkey
//   ../@fin/keyboard
//   ../@fin/command
//   ../@fin/disposable
//   ../@fin/event

import { ContextKeyExpr } from '@fin/contextkey';
import { Keybinding } from '@fin/keyboard';
import { ICommandHandler } from '@fin/command';
import { Disposable } from '@fin/disposable';
import { Event, Emitter } from '@fin/event';
import { IContextKeyService, IContextKeyServiceTarget } from '@fin/contextkey';
import { ICommandService } from '@fin/command';
import { IContext } from '@fin/contextkey';
import { Event } from '@fin/event';
import { KeyCode, Keybinding } from '@fin/keyboard';
import { IContextKeyServiceTarget } from '@fin/contextkey';

export interface IKeybindingItem {
    keybinding: Keybinding;
    command: string;
    commandArgs?: any;
    when: ContextKeyExpr;
    weight1: number;
    weight2: number;
}
export interface IKeybindings {
    primary: number;
    secondary?: number[];
    win?: {
        primary: number;
        secondary?: number[];
    };
    linux?: {
        primary: number;
        secondary?: number[];
    };
    mac?: {
        primary: number;
        secondary?: number[];
    };
}
export interface IKeybindingRule extends IKeybindings {
    id: string;
    weight: number;
    when: ContextKeyExpr;
}
export interface IKeybindingsRegistry {
    registerKeybindingRule(rule: IKeybindingRule): void;
    getDefaultKeybindings(): IKeybindingItem[];
    registerCommandAndKeybindingRule(desc: ICommandAndKeybindingRule): void;
}
export interface ICommandAndKeybindingRule extends IKeybindingRule {
    handler: ICommandHandler;
}
class KeybindingsRegistryImpl implements IKeybindingsRegistry {
    constructor();
    registerKeybindingRule(rule: IKeybindingRule): void;
    registerCommandAndKeybindingRule(desc: ICommandAndKeybindingRule): void;
    getDefaultKeybindings(): IKeybindingItem[];
}
export const KeybindingsRegistry: KeybindingsRegistryImpl;
export {};

export class KeybindingService extends Disposable implements IKeybindingService {
    protected _onDidUpdateKeybindings: Emitter<IKeybindingEvent>;
    protected _commandService: ICommandService;
    constructor(windowElement: Window, contextKeyService: IContextKeyService, commandService: ICommandService);
    dispose(): void;
    readonly onDidUpdateKeybindings: Event<IKeybindingEvent>;
    protected _getResolver(): KeybindingResolver;
    protected _documentHasFocus(): boolean;
    resolveKeybinding(kb: Keybinding): ResolvedKeybinding[];
    resolveKeyboardEvent(keyboardEvent: IKeyboardEventLite): ResolvedKeybinding;
    resolveUserBinding(userBinding: string): ResolvedKeybinding[];
    getDefaultKeybindingsContent(): string;
    getDefaultKeybindings(): ResolvedKeybindingItem[];
    getKeybindings(): ResolvedKeybindingItem[];
    customKeybindingsCount(): number;
    lookupKeybindings(commandId: string): ResolvedKeybinding[];
    lookupKeybinding(commandId: string): ResolvedKeybinding;
    softDispatch(e: IKeyboardEventLite, target: IContextKeyServiceTarget): IResolveResult;
    protected _dispatch(e: IKeyboardEventLite, target: IContextKeyServiceTarget): boolean;
}

export interface IResolveResult {
        enterChord: boolean;
        commandId: string;
        commandArgs: any;
        bubble: boolean;
}
export class KeybindingResolver {
        constructor(defaultKeybindings: ResolvedKeybindingItem[], overrides: ResolvedKeybindingItem[]);
        /**
            * Looks for rules containing -command in `overrides` and removes them directly from `defaults`.
            */
        static combine(defaults: ResolvedKeybindingItem[], rawOverrides: ResolvedKeybindingItem[]): ResolvedKeybindingItem[];
        /**
            * Returns true if it is provable `a` implies `b`.
            * **Precondition**: Assumes `a` and `b` are normalized!
            */
        static whenIsEntirelyIncluded(a: ContextKeyExpr, b: ContextKeyExpr): boolean;
        getDefaultBoundCommands(): Map<string, boolean>;
        getDefaultKeybindings(): ResolvedKeybindingItem[];
        getKeybindings(): ResolvedKeybindingItem[];
        lookupKeybindings(commandId: string): ResolvedKeybindingItem[];
        lookupPrimaryKeybinding(commandId: string): ResolvedKeybindingItem;
        resolve(context: IContext, currentChord: string, keypress: string): IResolveResult;
        static contextMatchesRules(context: IContext, rules: ContextKeyExpr): boolean;
        static getAllUnboundCommands(boundCommands: Map<string, boolean>): string[];
}

export class ResolvedKeybindingItem {
    _resolvedKeybindingItemBrand: void;
    readonly resolvedKeybinding: ResolvedKeybinding;
    readonly keypressFirstPart: string;
    readonly keypressChordPart: string;
    readonly bubble: boolean;
    readonly command: string;
    readonly commandArgs: any;
    readonly when: ContextKeyExpr;
    readonly isDefault: boolean;
    constructor(resolvedKeybinding: ResolvedKeybinding, command: string, commandArgs: any, when: ContextKeyExpr, isDefault: boolean);
}

export interface IUserFriendlyKeybinding {
        key: string;
        command: string;
        args?: any;
        when?: string;
}
export enum KeybindingSource {
        Default = 1,
        User = 2
}
export interface IKeybindingEvent {
        source: KeybindingSource;
        keybindings?: IUserFriendlyKeybinding[];
}
export interface IKeyboardEventLite {
        readonly ctrlKey: boolean;
        readonly shiftKey: boolean;
        readonly altKey: boolean;
        readonly metaKey: boolean;
        readonly keyCode: KeyCode;
        readonly code: string;
}
export interface IKeybindingService {
        onDidUpdateKeybindings: Event<IKeybindingEvent>;
        /**
            * Returns none, one or many (depending on keyboard layout)!
            */
        resolveKeybinding(keybinding: Keybinding): ResolvedKeybinding[];
        resolveKeyboardEvent(keyboardEvent: IKeyboardEventLite): ResolvedKeybinding;
        resolveUserBinding(userBinding: string): ResolvedKeybinding[];
        /**
            * Resolve and dispatch `keyboardEvent`, but do not invoke the command or change inner state.
            */
        softDispatch(keyboardEvent: IKeyboardEventLite, target: IContextKeyServiceTarget): IResolveResult;
        /**
            * Look up keybindings for a command.
            * Use `lookupKeybinding` if you are interested in the preferred keybinding.
            */
        lookupKeybindings(commandId: string): ResolvedKeybinding[];
        /**
            * Look up the preferred (last defined) keybinding for a command.
            * @returns The preferred keybinding or null if the command is not bound.
            */
        lookupKeybinding(commandId: string): ResolvedKeybinding;
        getDefaultKeybindingsContent(): string;
        getDefaultKeybindings(): ResolvedKeybindingItem[];
        getKeybindings(): ResolvedKeybindingItem[];
        customKeybindingsCount(): number;
}

export class ResolvedKeybindingPart {
        readonly ctrlKey: boolean;
        readonly shiftKey: boolean;
        readonly altKey: boolean;
        readonly metaKey: boolean;
        readonly keyLabel: string;
        readonly keyAriaLabel: string;
        constructor(ctrlKey: boolean, shiftKey: boolean, altKey: boolean, metaKey: boolean, kbLabel: string, kbAriaLabel: string);
}
/**
    * A resolved keybinding. Can be a simple keybinding or a chord keybinding.
    */
export abstract class ResolvedKeybinding {
        /**
            * This prints the binding in a format suitable for displaying in the UI.
            */
        abstract getLabel(): string;
        /**
            * This prints the binding in a format suitable for ARIA.
            */
        abstract getAriaLabel(): string;
        /**
            * This prints the binding in a format suitable for user settings.
            */
        abstract getUserSettingsLabel(): string;
        /**
            * Is the user settings label reflecting the label?
            */
        abstract isWYSIWYG(): boolean;
        /**
            * Is the binding a chord?
            */
        abstract isChord(): boolean;
        /**
            * Returns the firstPart, chordPart that should be used for dispatching.
            */
        abstract getDispatchParts(): [string, string];
        /**
            * Returns the firstPart, chordPart of the keybinding.
            * For simple keybindings, the second element will be null.
            */
        abstract getParts(): [ResolvedKeybindingPart, ResolvedKeybindingPart];
}

